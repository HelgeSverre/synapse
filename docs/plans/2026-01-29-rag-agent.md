# RAG Agent Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Create an agent that combines embeddings with tool calling to answer questions from a knowledge base, demonstrating RAG (Retrieval-Augmented Generation) with multi-hop retrieval and citation tracking.

**Architecture:** The agent has access to `search_knowledge` and `get_document` tools. `search_knowledge` embeds the query, searches an in-memory vector store, and returns relevant chunks with IDs. The agent can call tools multiple times for multi-hop retrieval. Citations are tracked and formatted in the final response.

**Tech Stack:** PHP 8.2+, StreamingLlmExecutorWithFunctions, existing embedding providers (OpenAI/Mistral), cosine similarity search, in-memory vector store

---

## Task 1: Create In-Memory Vector Store

**Files:**
- Create: `examples/rag-agent/Document.php`
- Create: `examples/rag-agent/Chunk.php`
- Create: `examples/rag-agent/VectorStore.php`

**Step 1: Create Document**

```php
<?php
// examples/rag-agent/Document.php
declare(strict_types=1);

namespace LlmExe\Examples\RagAgent;

/**
 * A document in the knowledge base.
 */
final readonly class Document
{
    public function __construct(
        public string $id,
        public string $title,
        public string $source,
        public string $content,
        public array $metadata = [],
    ) {}

    /**
     * Split document into chunks.
     * 
     * @return list<Chunk>
     */
    public function chunk(int $chunkSize = 500, int $overlap = 50): array
    {
        $chunks = [];
        $words = preg_split('/\s+/', $this->content);
        $totalWords = count($words);
        
        $index = 0;
        $chunkNum = 0;
        
        while ($index < $totalWords) {
            $chunkWords = array_slice($words, $index, $chunkSize);
            $text = implode(' ', $chunkWords);
            
            $chunks[] = new Chunk(
                id: "{$this->id}_c{$chunkNum}",
                documentId: $this->id,
                source: $this->source,
                text: $text,
                position: $chunkNum,
            );
            
            $index += $chunkSize - $overlap;
            $chunkNum++;
        }
        
        return $chunks;
    }
}
```

**Step 2: Create Chunk**

```php
<?php
// examples/rag-agent/Chunk.php
declare(strict_types=1);

namespace LlmExe\Examples\RagAgent;

/**
 * A chunk of text from a document, with its embedding.
 */
final class Chunk
{
    /** @var list<float>|null */
    public ?array $embedding = null;

    public function __construct(
        public readonly string $id,
        public readonly string $documentId,
        public readonly string $source,
        public readonly string $text,
        public readonly int $position = 0,
    ) {}

    /**
     * @param list<float> $embedding
     */
    public function setEmbedding(array $embedding): void
    {
        $this->embedding = $embedding;
    }

    public function toSearchResult(float $score): array
    {
        return [
            'id' => $this->id,
            'document_id' => $this->documentId,
            'source' => $this->source,
            'text' => $this->text,
            'score' => round($score, 4),
        ];
    }
}
```

**Step 3: Create VectorStore**

```php
<?php
// examples/rag-agent/VectorStore.php
declare(strict_types=1);

namespace LlmExe\Examples\RagAgent;

use LlmExe\Embeddings\EmbeddingProviderInterface;

/**
 * Simple in-memory vector store with cosine similarity search.
 */
final class VectorStore
{
    /** @var array<string, Chunk> */
    private array $chunks = [];

    /** @var array<string, Document> */
    private array $documents = [];

    public function __construct(
        private readonly EmbeddingProviderInterface $embeddingProvider,
        private readonly string $embeddingModel,
    ) {}

    /**
     * Add a document and embed its chunks.
     */
    public function addDocument(Document $document, int $chunkSize = 500): void
    {
        $this->documents[$document->id] = $document;
        
        $chunks = $document->chunk($chunkSize);
        
        // Embed all chunks in batch
        $texts = array_map(fn(Chunk $c) => $c->text, $chunks);
        $response = $this->embeddingProvider->embed($texts, $this->embeddingModel);
        
        foreach ($chunks as $i => $chunk) {
            $chunk->setEmbedding($response->embeddings[$i]);
            $this->chunks[$chunk->id] = $chunk;
        }
    }

    /**
     * Search for chunks similar to the query.
     * 
     * @return list<array{id: string, document_id: string, source: string, text: string, score: float}>
     */
    public function search(string $query, int $topK = 5): array
    {
        if (empty($this->chunks)) {
            return [];
        }

        // Embed query
        $response = $this->embeddingProvider->embed($query, $this->embeddingModel);
        $queryEmbedding = $response->embeddings[0];

        // Calculate similarities
        $scores = [];
        foreach ($this->chunks as $id => $chunk) {
            if ($chunk->embedding === null) {
                continue;
            }
            $scores[$id] = $this->cosineSimilarity($queryEmbedding, $chunk->embedding);
        }

        // Sort by score descending
        arsort($scores);

        // Return top K
        $results = [];
        $count = 0;
        foreach ($scores as $id => $score) {
            if ($count >= $topK) {
                break;
            }
            $results[] = $this->chunks[$id]->toSearchResult($score);
            $count++;
        }

        return $results;
    }

    /**
     * Get a full document by ID.
     */
    public function getDocument(string $id): ?Document
    {
        return $this->documents[$id] ?? null;
    }

    /**
     * Get a chunk by ID.
     */
    public function getChunk(string $id): ?Chunk
    {
        return $this->chunks[$id] ?? null;
    }

    /**
     * @return list<string>
     */
    public function getDocumentIds(): array
    {
        return array_keys($this->documents);
    }

    public function getStats(): array
    {
        return [
            'documents' => count($this->documents),
            'chunks' => count($this->chunks),
        ];
    }

    /**
     * Calculate cosine similarity between two vectors.
     * 
     * @param list<float> $a
     * @param list<float> $b
     */
    private function cosineSimilarity(array $a, array $b): float
    {
        if (count($a) !== count($b)) {
            return 0.0;
        }

        $dotProduct = 0.0;
        $normA = 0.0;
        $normB = 0.0;

        for ($i = 0, $len = count($a); $i < $len; $i++) {
            $dotProduct += $a[$i] * $b[$i];
            $normA += $a[$i] * $a[$i];
            $normB += $b[$i] * $b[$i];
        }

        $normA = sqrt($normA);
        $normB = sqrt($normB);

        if ($normA == 0 || $normB == 0) {
            return 0.0;
        }

        return $dotProduct / ($normA * $normB);
    }
}
```

**Step 4: Verify syntax**

Run: `php -l examples/rag-agent/Document.php && php -l examples/rag-agent/Chunk.php && php -l examples/rag-agent/VectorStore.php`

---

## Task 2: Create RAG Tools

**Files:**
- Create: `examples/rag-agent/RagTools.php`

**Step 1: Create the tools**

```php
<?php
// examples/rag-agent/RagTools.php
declare(strict_types=1);

namespace LlmExe\Examples\RagAgent;

use LlmExe\Executor\CallableExecutor;

/**
 * Tools for RAG: search and document retrieval.
 */
final class RagTools
{
    /** @var array<string, array{source: string, text: string}> Track retrieved chunks */
    private array $retrievedChunks = [];

    public function __construct(
        private readonly VectorStore $vectorStore,
    ) {}

    /**
     * Create the search_knowledge tool.
     */
    public function searchKnowledge(): CallableExecutor
    {
        return new CallableExecutor(
            name: 'search_knowledge',
            description: 'Search the knowledge base for relevant information. Returns chunks with IDs that can be cited.',
            handler: function (array $args): string {
                $query = $args['query'] ?? '';
                $topK = min($args['top_k'] ?? 5, 10);

                if ($query === '') {
                    return json_encode(['error' => 'Query is required']);
                }

                $results = $this->vectorStore->search($query, $topK);

                // Track retrieved chunks for citation
                foreach ($results as $result) {
                    $this->retrievedChunks[$result['id']] = [
                        'source' => $result['source'],
                        'text' => $result['text'],
                    ];
                }

                return json_encode([
                    'query' => $query,
                    'results_count' => count($results),
                    'results' => $results,
                    'hint' => 'Cite sources using the chunk IDs in brackets, e.g., [doc1_c0]',
                ], JSON_THROW_ON_ERROR);
            },
            parameters: [
                'type' => 'object',
                'properties' => [
                    'query' => [
                        'type' => 'string',
                        'description' => 'The search query - be specific and use key terms',
                    ],
                    'top_k' => [
                        'type' => 'integer',
                        'description' => 'Number of results to return (default: 5, max: 10)',
                    ],
                ],
                'required' => ['query'],
            ],
        );
    }

    /**
     * Create the get_document tool for full document retrieval.
     */
    public function getDocument(): CallableExecutor
    {
        return new CallableExecutor(
            name: 'get_document',
            description: 'Get the full content of a document by ID. Use when you need more context than the search chunks provide.',
            handler: function (array $args): string {
                $docId = $args['document_id'] ?? '';

                $document = $this->vectorStore->getDocument($docId);

                if ($document === null) {
                    return json_encode([
                        'error' => "Document not found: {$docId}",
                        'available' => $this->vectorStore->getDocumentIds(),
                    ]);
                }

                return json_encode([
                    'id' => $document->id,
                    'title' => $document->title,
                    'source' => $document->source,
                    'content' => $document->content,
                ], JSON_THROW_ON_ERROR);
            },
            parameters: [
                'type' => 'object',
                'properties' => [
                    'document_id' => [
                        'type' => 'string',
                        'description' => 'The document ID (from search results)',
                    ],
                ],
                'required' => ['document_id'],
            ],
        );
    }

    /**
     * Get all retrieved chunks for citation formatting.
     * 
     * @return array<string, array{source: string, text: string}>
     */
    public function getRetrievedChunks(): array
    {
        return $this->retrievedChunks;
    }

    /**
     * Format sources for display.
     */
    public function formatSources(): string
    {
        if (empty($this->retrievedChunks)) {
            return '';
        }

        $lines = ["\n---\n**Sources:**"];

        foreach ($this->retrievedChunks as $id => $chunk) {
            $lines[] = "- [{$id}] {$chunk['source']}";
        }

        return implode("\n", $lines);
    }

    public function reset(): void
    {
        $this->retrievedChunks = [];
    }
}
```

**Step 2: Verify syntax**

Run: `php -l examples/rag-agent/RagTools.php`

---

## Task 3: Create Sample Knowledge Base

**Files:**
- Create: `examples/rag-agent/SampleKnowledgeBase.php`

**Step 1: Create sample documents**

```php
<?php
// examples/rag-agent/SampleKnowledgeBase.php
declare(strict_types=1);

namespace LlmExe\Examples\RagAgent;

/**
 * Sample knowledge base with documentation for demo purposes.
 */
final class SampleKnowledgeBase
{
    /**
     * @return list<Document>
     */
    public static function getDocuments(): array
    {
        return [
            new Document(
                id: 'refund_policy',
                title: 'Refund Policy',
                source: 'policies/refund-policy.md',
                content: <<<CONTENT
                # Refund Policy

                ## Digital Products
                Digital products (software licenses, e-books, online courses) are non-refundable once the download link has been accessed or the content has been viewed. However, we offer a 30-day satisfaction guarantee: if you experience technical issues that prevent you from using the product, contact support for a full refund.

                ## Physical Products
                Physical products may be returned within 60 days of purchase for a full refund. Items must be unused and in original packaging. Shipping costs for returns are the customer's responsibility unless the item was defective.

                ## Subscription Services
                Subscription services can be cancelled at any time. Refunds for unused portions of annual subscriptions are prorated. Monthly subscriptions are not refunded but will not renew. Contact billing@example.com for subscription issues.

                ## How to Request a Refund
                1. Log into your account at account.example.com
                2. Navigate to Order History
                3. Click "Request Refund" next to the order
                4. Provide reason and any supporting information
                5. Wait 3-5 business days for review

                Refunds are processed to the original payment method within 7-10 business days after approval.
                CONTENT,
            ),

            new Document(
                id: 'api_authentication',
                title: 'API Authentication Guide',
                source: 'docs/api/authentication.md',
                content: <<<CONTENT
                # API Authentication

                ## Overview
                Our API uses Bearer token authentication. All requests must include an Authorization header with a valid API key.

                ## Getting an API Key
                1. Log into the Developer Portal at developers.example.com
                2. Navigate to API Keys section
                3. Click "Create New Key"
                4. Choose permissions: read-only or read-write
                5. Copy and securely store your key (it won't be shown again)

                ## Using Your API Key
                Include the key in every request header:
                ```
                Authorization: Bearer your-api-key-here
                ```

                ## Rate Limits
                - Free tier: 100 requests per minute
                - Pro tier: 1000 requests per minute
                - Enterprise: Custom limits

                Rate limit headers are included in every response:
                - X-RateLimit-Limit: Maximum requests allowed
                - X-RateLimit-Remaining: Requests remaining in window
                - X-RateLimit-Reset: Unix timestamp when limit resets

                ## Security Best Practices
                - Never expose API keys in client-side code
                - Rotate keys every 90 days
                - Use environment variables for key storage
                - Monitor usage for unusual patterns
                - Immediately revoke compromised keys
                CONTENT,
            ),

            new Document(
                id: 'shipping_info',
                title: 'Shipping Information',
                source: 'help/shipping.md',
                content: <<<CONTENT
                # Shipping Information

                ## Domestic Shipping (United States)
                - Standard (5-7 business days): Free on orders over $50, otherwise $5.99
                - Express (2-3 business days): $12.99
                - Next Day: $24.99 (order by 2pm EST)

                ## International Shipping
                - Canada and Mexico: $15.99 (7-14 business days)
                - Europe: $24.99 (10-21 business days)
                - Rest of World: $34.99 (14-30 business days)

                International orders may be subject to customs duties and taxes, which are the customer's responsibility.

                ## Tracking Your Order
                Tracking numbers are emailed within 24 hours of shipment. Track at track.example.com or use the carrier's website directly.

                ## Shipping Restrictions
                We cannot ship to P.O. boxes for orders containing lithium batteries. Some products have country-specific restrictions due to regulations.

                ## Lost or Damaged Packages
                Contact support within 14 days of expected delivery date. We will file a claim with the carrier and either reship or refund your order.
                CONTENT,
            ),

            new Document(
                id: 'privacy_policy',
                title: 'Privacy Policy',
                source: 'legal/privacy.md',
                content: <<<CONTENT
                # Privacy Policy

                Last updated: January 2026

                ## Data We Collect
                - Account information: name, email, password hash
                - Payment data: processed by Stripe, we don't store card numbers
                - Usage data: pages visited, features used, error logs
                - Device information: browser type, OS, IP address

                ## How We Use Your Data
                - Provide and improve our services
                - Process transactions
                - Send service communications
                - Detect fraud and abuse
                - Comply with legal obligations

                ## Data Retention
                - Account data: kept while account is active
                - Transaction records: 7 years for tax purposes
                - Usage logs: 90 days
                - Support tickets: 3 years

                ## Your Rights (GDPR/CCPA)
                - Access your data
                - Correct inaccuracies
                - Delete your account
                - Export your data
                - Opt out of marketing

                Contact privacy@example.com to exercise these rights.

                ## Cookies
                We use essential cookies for authentication and preferences. Analytics cookies are optional and can be disabled in settings.
                CONTENT,
            ),
        ];
    }
}
```

**Step 2: Verify syntax**

Run: `php -l examples/rag-agent/SampleKnowledgeBase.php`

---

## Task 4: Create Main CLI Script

**Files:**
- Create: `examples/rag-agent-cli.php`

**Step 1: Create the CLI**

```php
<?php
// examples/rag-agent-cli.php
declare(strict_types=1);

/**
 * RAG Agent Demo
 * 
 * Demonstrates an agent that:
 * 1. Searches a knowledge base using embeddings
 * 2. Retrieves relevant document chunks
 * 3. Answers questions with citations
 * 4. Supports multi-hop retrieval
 * 
 * Usage:
 *   php examples/rag-agent-cli.php [provider]
 * 
 * Requires: OPENAI_API_KEY for embeddings (uses text-embedding-3-small)
 */

require_once __DIR__ . '/../vendor/autoload.php';
require_once __DIR__ . '/rag-agent/Document.php';
require_once __DIR__ . '/rag-agent/Chunk.php';
require_once __DIR__ . '/rag-agent/VectorStore.php';
require_once __DIR__ . '/rag-agent/RagTools.php';
require_once __DIR__ . '/rag-agent/SampleKnowledgeBase.php';

use GuzzleHttp\Client;
use LlmExe\Embeddings\OpenAIEmbeddingProvider;
use LlmExe\Examples\RagAgent\RagTools;
use LlmExe\Examples\RagAgent\SampleKnowledgeBase;
use LlmExe\Examples\RagAgent\VectorStore;
use LlmExe\Executor\StreamingLlmExecutorWithFunctions;
use LlmExe\Executor\UseExecutors;
use LlmExe\Prompt\TextPrompt;
use LlmExe\Provider\Anthropic\AnthropicProvider;
use LlmExe\Provider\Http\GuzzleStreamTransport;
use LlmExe\Provider\Http\Psr18Transport;
use LlmExe\Provider\OpenAI\OpenAIProvider;
use LlmExe\State\Message;
use LlmExe\Streaming\StreamCompleted;
use LlmExe\Streaming\TextDelta;
use LlmExe\Streaming\ToolCallsReady;

const CYAN = "\033[36m";
const GREEN = "\033[32m";
const YELLOW = "\033[33m";
const RED = "\033[31m";
const MAGENTA = "\033[35m";
const RESET = "\033[0m";
const BOLD = "\033[1m";
const DIM = "\033[2m";

function createProvider(string $name, $transport): array
{
    return match ($name) {
        'openai' => [
            new OpenAIProvider($transport, getenv('OPENAI_API_KEY') ?: exit(RED . "OPENAI_API_KEY not set\n" . RESET)),
            'gpt-4o-mini',
        ],
        'anthropic' => [
            new AnthropicProvider($transport, getenv('ANTHROPIC_API_KEY') ?: exit(RED . "ANTHROPIC_API_KEY not set\n" . RESET)),
            'claude-3-haiku-20240307',
        ],
        default => exit(RED . "Unknown provider: {$name}\n" . RESET),
    };
}

// Check for API key
$openaiKey = getenv('OPENAI_API_KEY');
if (!$openaiKey) {
    echo RED . "OPENAI_API_KEY is required for embeddings\n" . RESET;
    exit(1);
}

// Banner
echo BOLD . CYAN . "
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘              RAG Agent Demo                           â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•" . RESET . "

This agent searches a knowledge base and answers with citations.

" . BOLD . "Knowledge Base Contents:" . RESET . "
  ðŸ“„ Refund Policy
  ðŸ“„ API Authentication Guide
  ðŸ“„ Shipping Information
  ðŸ“„ Privacy Policy

" . BOLD . "Example questions:" . RESET . "
  â€¢ \"What's the refund policy for digital products?\"
  â€¢ \"How do I authenticate API requests?\"
  â€¢ \"What are the shipping options to Europe?\"
  â€¢ \"How long do you keep my data?\"

" . DIM . "Loading knowledge base and generating embeddings..." . RESET . "\n";

// Setup
$providerName = $argv[1] ?? 'openai';
$guzzle = new Client(['timeout' => 120]);
$transport = new GuzzleStreamTransport($guzzle);
$psr18Transport = new Psr18Transport($guzzle);

[$provider, $model] = createProvider($providerName, $transport);

// Create embedding provider and vector store
$embeddingProvider = new OpenAIEmbeddingProvider($psr18Transport, $openaiKey);
$vectorStore = new VectorStore($embeddingProvider, 'text-embedding-3-small');

// Load sample documents
$documents = SampleKnowledgeBase::getDocuments();
foreach ($documents as $doc) {
    echo DIM . "  Indexing: {$doc->title}..." . RESET . "\n";
    $vectorStore->addDocument($doc, chunkSize: 200);
}

$stats = $vectorStore->getStats();
echo GREEN . "âœ… Indexed {$stats['documents']} documents ({$stats['chunks']} chunks)" . RESET . "\n";
echo CYAN . "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”" . RESET . "\n\n";

// Create RAG tools
$ragTools = new RagTools($vectorStore);
$tools = new UseExecutors([
    $ragTools->searchKnowledge(),
    $ragTools->getDocument(),
]);

// System prompt
$systemPrompt = <<<PROMPT
You are a helpful assistant that answers questions using a knowledge base.

## Instructions
1. Use the search_knowledge tool to find relevant information
2. If you need more context, use get_document to retrieve full documents
3. Always cite your sources using chunk IDs in brackets like [refund_policy_c0]
4. If the knowledge base doesn't contain relevant information, say so clearly
5. Be concise but thorough

## Multi-hop Retrieval
If your first search doesn't find enough information, try:
- Different search terms
- More specific queries
- Retrieving the full document for more context
PROMPT;

$prompt = (new TextPrompt())->setContent('{{message}}');
$messages = [Message::system($systemPrompt)];

// Main loop
while (true) {
    echo BOLD . GREEN . "Question: " . RESET;
    $input = trim(fgets(STDIN) ?: '');

    if ($input === '' || $input === '/exit') {
        echo DIM . "Goodbye!" . RESET . "\n";
        break;
    }

    // Reset citation tracking
    $ragTools->reset();

    $messages[] = Message::user($input);

    $executor = new StreamingLlmExecutorWithFunctions(
        provider: $provider,
        prompt: $prompt,
        model: $model,
        tools: $tools,
        maxIterations: 5,
        maxTokens: 1024,
    );

    echo "\n" . BOLD . CYAN . "Answer: " . RESET;

    $responseText = '';

    try {
        foreach ($executor->stream([
            'message' => $input,
            '_dialogueKey' => 'history',
            'history' => array_slice($messages, 0, -1),
        ]) as $event) {
            if ($event instanceof TextDelta) {
                echo $event->text;
                $responseText .= $event->text;
                flush();
            }

            if ($event instanceof ToolCallsReady) {
                echo DIM . "\n[Searching...]" . RESET . "\n";
            }

            if ($event instanceof StreamCompleted) {
                // Done
            }
        }
    } catch (\Throwable $e) {
        echo "\n" . RED . "Error: " . $e->getMessage() . RESET . "\n";
        array_pop($messages);
        continue;
    }

    // Show sources
    $sources = $ragTools->formatSources();
    if ($sources !== '') {
        echo DIM . $sources . RESET;
    }

    if ($responseText !== '') {
        $messages[] = Message::assistant($responseText);
    }

    echo "\n\n";
}
```

**Step 2: Verify syntax**

Run: `php -l examples/rag-agent-cli.php`

---

## Task 5: Write Tests

**Files:**
- Create: `tests/Unit/Examples/RagAgentTest.php`

**Step 1: Create test file**

```php
<?php
declare(strict_types=1);

namespace LlmExe\Tests\Unit\Examples;

require_once __DIR__ . '/../../../examples/rag-agent/Document.php';
require_once __DIR__ . '/../../../examples/rag-agent/Chunk.php';
require_once __DIR__ . '/../../../examples/rag-agent/SampleKnowledgeBase.php';

use LlmExe\Examples\RagAgent\Chunk;
use LlmExe\Examples\RagAgent\Document;
use LlmExe\Examples\RagAgent\SampleKnowledgeBase;
use PHPUnit\Framework\TestCase;

final class RagAgentTest extends TestCase
{
    public function test_document_chunks_content(): void
    {
        $doc = new Document(
            id: 'test',
            title: 'Test Doc',
            source: 'test.md',
            content: str_repeat('word ', 100), // 100 words
        );

        $chunks = $doc->chunk(chunkSize: 30, overlap: 5);

        $this->assertGreaterThan(1, count($chunks));
        $this->assertSame('test_c0', $chunks[0]->id);
        $this->assertSame('test', $chunks[0]->documentId);
    }

    public function test_chunk_creates_search_result(): void
    {
        $chunk = new Chunk(
            id: 'doc1_c0',
            documentId: 'doc1',
            source: 'docs/test.md',
            text: 'This is test content',
            position: 0,
        );

        $result = $chunk->toSearchResult(0.95);

        $this->assertSame('doc1_c0', $result['id']);
        $this->assertSame('doc1', $result['document_id']);
        $this->assertSame('docs/test.md', $result['source']);
        $this->assertSame(0.95, $result['score']);
    }

    public function test_chunk_stores_embedding(): void
    {
        $chunk = new Chunk('c1', 'd1', 'source', 'text');
        
        $this->assertNull($chunk->embedding);

        $embedding = [0.1, 0.2, 0.3];
        $chunk->setEmbedding($embedding);

        $this->assertSame($embedding, $chunk->embedding);
    }

    public function test_sample_knowledge_base_has_documents(): void
    {
        $docs = SampleKnowledgeBase::getDocuments();

        $this->assertGreaterThan(0, count($docs));

        $ids = array_map(fn($d) => $d->id, $docs);
        $this->assertContains('refund_policy', $ids);
        $this->assertContains('api_authentication', $ids);
    }

    public function test_document_has_required_properties(): void
    {
        $doc = new Document(
            id: 'test_doc',
            title: 'Test Title',
            source: 'test/source.md',
            content: 'Test content here',
            metadata: ['author' => 'Test'],
        );

        $this->assertSame('test_doc', $doc->id);
        $this->assertSame('Test Title', $doc->title);
        $this->assertSame('test/source.md', $doc->source);
        $this->assertSame('Test content here', $doc->content);
        $this->assertSame(['author' => 'Test'], $doc->metadata);
    }
}
```

**Step 2: Run tests**

Run: `./vendor/bin/phpunit tests/Unit/Examples/RagAgentTest.php --no-coverage`

---

## Task 6: Final Verification

**Step 1: Run all unit tests**

Run: `./vendor/bin/phpunit --testsuite=Unit --no-coverage`

**Step 2: Run PHPStan**

Run: `./vendor/bin/phpstan analyse src/ --no-progress`

**Step 3: Run Pint**

Run: `./vendor/bin/pint`

---

## Execution Options

Plan complete. Two execution options:

**1. Subagent-Driven (this session)** - I dispatch fresh subagent per task, review between tasks, fast iteration

**2. Parallel Session (separate)** - Open new session with executing-plans, batch execution with checkpoints

Which approach?
